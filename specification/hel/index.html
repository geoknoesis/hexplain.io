<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hexplain Expression Language (HEL) Specification</title>
    <!-- ReSpec script and configuration -->
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="respec" async></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            editors: [{
                name: "Stephane Fellah",
                url: "https://geoknoesis.com/"
            }],
            github: "https://github.com/w3c/respec",
            shortName: "hel",
            publishDate: "2025-08-16",
            subtitle: "Version 1.0",
        };
    </script>
</head>
<body>
    <section id="abstract">
        <p>
            The Hexplain Expression Language (HEL) is a simple, declarative language designed for expressing conditions and calculations within Hexplain format descriptions. It provides the necessary logic for features such as dynamic sizing, conditional field presence, and repetitive structures. HEL is designed to be minimal, intuitive for developers, and grounded in existing web standards for its semantics. It operates on a simple logical data model that is derived from the binary data being parsed, using a context-based mapping inspired by JSON-LD to resolve field names.
        </p>
    </section>

    <section id="sotd">
        <p>
            This document is an unofficial draft produced for the purpose of defining the Hexplain standard. It has no official standing and is not endorsed by any standards body. Version 1.2 introduces the <code>parent</code> keyword for upward navigation and support for arithmetic expressions. Version 1.1 introduced support for parenthesized expressions.
        </p>
    </section>

    <section class="introductory">
        <h2>Introduction</h2>
        <p>
            The Hexplain standard provides a declarative framework for describing the physical layout and semantic meaning of binary data formats. A key requirement of this framework is the ability to handle dynamic structures where the presence, size, or repetition of a field depends on the value of previously parsed data.
        </p>
        <p>
            The Hexplain Expression Language (HEL) provides a concise and unambiguous syntax for these conditions. Its design goals are:
        </p>
        <ul>
            <li><b>Simplicity:</b> The language should be small and easy to learn for anyone familiar with modern programming languages.</li>
            <li><b>Clarity:</b> Expressions should be readable and their intent should be obvious.</li>
            <li><b>Standard-Based:</b> The semantics of its operators and data model should be grounded in existing, stable standards like JSON-LD and XPath.</li>
        </ul>
        <p>
            HEL is used exclusively within Hexplain descriptions, typically as the literal value for properties like <code>bddo:repeatUntil</code>, <code>bddo:isPresentIf</code>, and <code>bddo:sizeFromExpression</code>.
        </p>
        <section>
            <h3>Conformance</h3>
            <p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].
            </p>
        </section>
    </section>

    <section id="data-model">
        <h2>The Logical Data Model</h2>
        <p>
            A HEL expression is not evaluated directly against an RDF graph. Instead, it is evaluated against a temporary, in-memory <b>Logical Data Model</b>, referred to as the "parsing context." This model is a simple, hierarchical key-value map, analogous to a JSON object.
        </p>
        <p>
            The keyword <code>instance</code> is a reserved term in HEL that refers to the root of the current parsing context. The parsing context is constructed by the Hexplain parser as it processes a binary stream.
        </p>

        <section>
            <h3>Context-Based Key Resolution</h3>
            <p>
                The keys in the Logical Data Model are simple strings (e.g., <code>"ChunkType"</code>). These simple keys are unambiguously mapped to their full URIs via a context, which is defined by the <code>@prefix</code> declarations in the Hexplain description file. This mechanism is directly inspired by [[JSON-LD]].
            </p>
        </section>
        <section>
            <h3>Hierarchical Context and the `parent` Keyword</h3>
            <p>
                The parsing context is hierarchical. The special identifier <code>parent</code> can be used within an accessor to navigate to the containing structure in the logical model. This allows an expression to reference sibling fields or attributes of the parent struct. For example, <code>instance.parent.siblingField</code>.
            </p>
        </section>
    </section>

    <section id="syntax">
        <h2>Syntax and Grammar</h2>
        <p>A HEL expression is a string literal that conforms to the grammar defined in this section.</p>

        <section>
            <h3>Formal Grammar (ABNF)</h3>
            <p>The following grammar, specified in Augmented Backus-Naur Form [[RFC5234]], defines the HEL syntax.</p>
            <pre class="abnf">
Expression      = LogicalTerm *( WS "or" WS LogicalTerm )
LogicalTerm     = ComparisonTerm *( WS "and" WS ComparisonTerm )
ComparisonTerm  = AdditiveExpr [ WS ( "==" / "!=" / "&lt;" / "&gt;" / "&lt;=" / "&gt;=" ) WS AdditiveExpr ]
AdditiveExpr    = MultiplicativeExpr *( WS ( "+" / "-" ) WS MultiplicativeExpr )
MultiplicativeExpr = PrimaryExpr *( WS ( "*" / "/" ) WS PrimaryExpr )

PrimaryExpr     = Accessor / Literal / ( "(" WS Expression WS ")" )

Accessor        = "instance" *( "." ( "parent" / IDENTIFIER ) )
Literal         = StringLiteral / IntegerLiteral / BooleanLiteral

StringLiteral   = %x27 *( CHAR ) %x27 ; single-quoted string
IntegerLiteral  = 1*DIGIT
BooleanLiteral  = "true" / "false"

IDENTIFIER      = ALPHA *( ALPHA / DIGIT / "_" )
CHAR            = %x20-26 / %x28-7E ; Any character except single quote
WS              = *( %x20 / %x09 ) ; Whitespace (space or tab)
            </pre>
        </section>

        <section>
            <h3>Accessors</h3>
            <p>
                Values from the logical model are accessed using dot-notation, starting with the <code>instance</code> keyword. The identifier following a dot MUST correspond to a key in the logical model, or be the special keyword <code>parent</code>.
            </p>
            <pre class="example">
instance.FieldName
instance.Header.Version
instance.parent.siblingField
            </pre>
        </section>

        <section>
            <h3>Operators</h3>
            <p>
                HEL supports comparison, logical, and arithmetic operators. The semantics of these operators are defined to be identical to their counterparts in [[xpath-functions-31]].
            </p>
            <table class="simple">
                <caption>Comparison & Logical Operators</caption>
                <thead><tr><th>Operator</th><th>Description</th></tr></thead>
                <tbody>
                    <tr><td><code>==</code>, <code>!=</code></td><td>Equality and Inequality</td></tr>
                    <tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>Numeric Comparison</td></tr>
                    <tr><td><code>and</code>, <code>or</code></td><td>Logical AND and OR</td></tr>
                </tbody>
            </table>
            <table class="simple">
                <caption>Arithmetic Operators</caption>
                <thead><tr><th>Operator</th><th>Description</th></tr></thead>
                <tbody>
                    <tr><td><code>+</code>, <code>-</code></td><td>Addition and Subtraction</td></tr>
                    <tr><td><code>*</code>, <code>/</code></td><td>Multiplication and Division</td></tr>
                </tbody>
            </table>
        </section>
    </section>

    <section id="evaluation">
        <h2>Evaluation Semantics</h2>
        <section>
            <h3>Operator Precedence</h3>
            <p>
                HEL defines a clear operator precedence to ensure unambiguous evaluation.
            </p>
            <ol>
                <li><b>Grouping:</b> Expressions within parentheses <code>()</code> are evaluated first.</li>
                <li><b>Multiplication & Division:</b> <code>*</code> and <code>/</code> are evaluated next.</li>
                <li><b>Addition & Subtraction:</b> <code>+</code> and <code>-</code> are evaluated after multiplication/division.</li>
                <li><b>Comparisons:</b> All comparison operators (<code>==</code>, <code>!=</code>, etc.) are evaluated after arithmetic.</li>
                <li><b>Logical AND:</b> The <code>and</code> operator is evaluated after comparisons.</li>
                <li><b>Logical OR:</b> The <code>or</code> operator is evaluated last.</li>
            </ol>
            <p>Within the same precedence level, evaluation proceeds from left to right.</p>
        </section>
        <section>
            <h3>Type System</h3>
            <p>
                Arithmetic operations MUST be performed on numeric types. An operation involving a non-numeric type is an error. Comparison operations follow the rules defined in the previous version of this specification.
            </p>
        </section>
    </section>

    <section id="conformance">
        <h2>Conformance</h2>
        <p>
            A conforming HEL implementation MUST:
        </p>
        <ol>
            <li>Implement a parser that correctly parses all valid expressions according to the ABNF grammar.</li>
            <li>Correctly implement the hierarchical parsing context, including the <code>instance</code> and <code>parent</code> keywords.</li>
            <li>Implement all specified operators with the correct precedence and type rules.</li>
            <li>Yield a single boolean result for expressions in a boolean context (e.g., <code>bddo:isPresentIf</code>) and a numeric result for expressions in a numeric context (e.g., <code>bddo:sizeFromExpression</code>).</li>
        </ol>
    </section>
    
    <section id="examples" class="introductory">
        <h2>Examples</h2>
        <dl>
            <dt>Referencing Sibling Fields</dt>
            <dd>
                Used in a conditional semantic mapping. This expression checks the value of the <code>Keyword</code> field, which is a sibling to the field this expression is attached to.
                <pre>hexplain:condition "instance.parent.Keyword == 'Title'"</pre>
            </dd>
            <dt>Dynamic Sizing with Expressions</dt>
            <dd>
                Used to calculate the size of a field based on other fields in the parent structure. The expression MUST evaluate to an integer.
                <pre>bddo:sizeFromExpression "instance.parent.totalSize - instance.parent.headerSize"</pre>
            </dd>
        </dl>
    </section>

</body>
</html>
