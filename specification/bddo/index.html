<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binary Data Description Ontology (BDDO) Specification</title>
    <!-- ReSpec script and configuration -->
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="respec" async></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            editors: [{
                name: "Stephane Fellah",
                url: "https://geoknoesis.com"
            }],
            github: "https://github.com/w3c/respec",
            shortName: "bddo",
            publishDate: "2025-08-16",
            subtitle: "Version 1.0",
        };
    </script>
</head>
<body>
    <section id="abstract">
        <p>
            The Binary Data Description Ontology (BDDO) provides a formal vocabulary to declaratively describe the structure, syntax, and layout of binary data. It is the foundational physical layer of the Hexplain Ontology Family. BDDO allows authors to model binary formats as a series of nested structures and typed fields, with support for dynamic layouts through conditional logic, variable sizing, and stream synchronization. This specification provides the normative OWL ontology for BDDO and a set of SHACL shapes for validating BDDO descriptions.
        </p>
    </section>

    <section id="sotd">
        <p>
            This document is an unofficial draft produced for the purpose of defining the Hexplain standard. It has no official standing and is not endorsed by any standards body. Version 1.1 introduces the <code>bddo:terminator</code> and <code>bddo:syncOnMarker</code> properties.
        </p>
    </section>

    <section class="introductory">
        <h2>Introduction</h2>
        <p>
            The primary goal of the Hexplain project is to make opaque binary data machine-understandable. The first step in this process is to provide a standardized, unambiguous way to describe the physical structure of the data. The Binary Data Description Ontology (BDDO) serves this purpose.
        </p>
        <p>
            BDDO provides a set of RDF classes and properties that can be used to create a graph-based model of a binary format. This model can then be used by a conforming Hexplain processor to parse a binary stream into a structured, logical representation.
        </p>
        <p>
            This specification is divided into several parts:
        </p>
        <ul>
            <li><b>Core Concepts:</b> An explanation of the main classes used in BDDO.</li>
            <li><b>Core Data Types:</b> A normative list of the built-in primitive data types.</li>
            <li><b>Properties:</b> A detailed reference for all properties used to describe structures and fields.</li>
            <li><b>Normative OWL Ontology:</b> The complete, machine-readable ontology in Turtle syntax.</li>
            <li><b>Normative SHACL Shapes:</b> A set of shapes for validating the correctness of BDDO descriptions themselves.</li>
            <li><b>Normative JSON-LD Context:</b> The official context for mapping BDDO terms to JSON.</li>
            <li><b>Examples:</b> Practical examples showing how BDDO is used to describe real-world formats.</li>
        </ul>
        <section>
            <h3>Conformance</h3>
            <p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].
            </p>
        </section>
    </section>

    <section id="core-concepts">
        <h2>Core Concepts</h2>
        <p>The BDDO model is built upon three fundamental classes.</p>
        <dl>
            <dt><code>bddo:Struct</code></dt>
            <dd>Represents a composite structure or a container for other elements. A Struct is an ordered sequence of Fields and other Structs. Examples include a file header, a network packet, or a PNG chunk.</dd>
            <dt><code>bddo:Field</code></dt>
            <dd>Represents a single, contiguous piece of data within a Struct. A Field is the smallest descriptive unit and is always associated with a specific data type.</dd>
            <dt><code>bddo:DataType</code></dt>
            <dd>Represents the type of data a Field contains. BDDO defines a set of core primitive data types (e.g., <code>bddo:uint32be</code>). This class can be extended in "profiles" to create user-defined type aliases (e.g., <code>media:fourCC</code>).</dd>
        </dl>
    </section>

    <section id="core-datatypes">
        <h2>Core Data Types</h2>
        <p>BDDO provides a normative set of built-in primitive data types. All conforming Hexplain processors MUST support these types. Each type is a formal instance of <code>bddo:DataType</code> and is described by the properties defined in the ontology.</p>
        
        <h3>Integer Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                    <th>bitWidth</th>
                    <th>isSigned</th>
                    <th>hasEndianness</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:uint8</code></td><td>Unsigned 8-bit integer</td><td>8</td><td>false</td><td>N/A</td></tr>
                <tr><td><code>bddo:int8</code></td><td>Signed 8-bit integer</td><td>8</td><td>true</td><td>N/A</td></tr>
                <tr><td><code>bddo:uint16be</code></td><td>Big-endian unsigned 16-bit integer</td><td>16</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint16le</code></td><td>Little-endian unsigned 16-bit integer</td><td>16</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int16be</code></td><td>Big-endian signed 16-bit integer</td><td>16</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int16le</code></td><td>Little-endian signed 16-bit integer</td><td>16</td><td>true</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:uint32be</code></td><td>Big-endian unsigned 32-bit integer</td><td>32</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint32le</code></td><td>Little-endian unsigned 32-bit integer</td><td>32</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int32be</code></td><td>Big-endian signed 32-bit integer</td><td>32</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int32le</code></td><td>Little-endian signed 32-bit integer</td><td>32</td><td>true</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:uint64be</code></td><td>Big-endian unsigned 64-bit integer</td><td>64</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint64le</code></td><td>Little-endian unsigned 64-bit integer</td><td>64</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int64be</code></td><td>Big-endian signed 64-bit integer</td><td>64</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int64le</code></td><td>Little-endian signed 64-bit integer</td><td>64</td><td>true</td><td>LittleEndian</td></tr>
            </tbody>
        </table>

        <h3>Floating-Point Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                    <th>bitWidth</th>
                    <th>hasEndianness</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:float32be</code></td><td>Big-endian IEEE 754 32-bit float</td><td>32</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:float32le</code></td><td>Little-endian IEEE 754 32-bit float</td><td>32</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:float64be</code></td><td>Big-endian IEEE 754 64-bit float</td><td>64</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:float64le</code></td><td>Little-endian IEEE 754 64-bit float</td><td>64</td><td>LittleEndian</td></tr>
            </tbody>
        </table>

        <h3>Other Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:bytes</code></td><td>Raw byte array. Requires a sizing property (e.g., <code>bddo:size</code>) or a termination property (<code>bddo:terminator</code>).</td></tr>
                <tr><td><code>bddo:string</code></td><td>String. Requires a sizing property or a termination property. May have an encoding property.</td></tr>
            </tbody>
        </table>
    </section>

    <section id="properties">
        <h2>Properties</h2>
        <p>Properties are the predicates that define the characteristics of Structs, Fields, and DataTypes.</p>
        <section>
            <h3>Structural Properties</h3>
            <dl>
                <dt><code>bddo:hasField</code></dt>
                <dd>Links a <code>bddo:Struct</code> to its constituent components. The object of this property MUST be an <code>rdf:List</code> to preserve the order of the fields.</dd>
                <dt><code>bddo:usesStruct</code></dt>
                <dd>Indicates that a <code>bddo:Struct</code> inherits the fields and properties of another <code>bddo:Struct</code>, used for creating reusable templates.</dd>
                <dt><code>bddo:endianness</code></dt>
                <dd>Specifies the byte order for a <code>bddo:Struct</code>. The value MUST be one of the individuals <code>bddo:BigEndian</code> or <code>bddo:LittleEndian</code>.</dd>
                <dt><code>bddo:syncOnMarker</code></dt>
                <dd>Specifies a byte sequence that a processor MUST scan for before parsing this <code>bddo:Struct</code>. The value MUST be an <code>xsd:hexBinary</code> literal.</dd>
            </dl>
        </section>
        <section>
            <h3>Field Properties</h3>
            <dl>
                <dt><code>bddo:dataType</code></dt>
                <dd>Links a <code>bddo:Field</code> to an instance of <code>bddo:DataType</code>.</dd>
                <dt><code>bddo:size</code></dt>
                <dd>Defines a fixed size in bytes for a field. The value MUST be an <code>xsd:positiveInteger</code>.</dd>
                <dt><code>bddo:sizeFromField</code></dt>
                <dd>For dynamic sizing, this property points to another <code>bddo:Field</code> in the structure whose value dictates the size of the current field. The target field MUST have an integer data type.</dd>
                <dt><code>bddo:terminator</code></dt>
                <dd>Specifies a byte sequence that terminates a variable-length field. The parser reads until this sequence is found. The value MUST be an <code>xsd:hexBinary</code> literal.</dd>
                <dt><code>bddo:hasFixedValue</code></dt>
                <dd>Specifies a constant value for a field, used for validating markers and magic numbers. The literal's datatype should match the field's data type.</dd>
            </dl>
        </section>
        <section>
            <h3>Control Flow Properties</h3>
             <dl>
                <dt><code>bddo:isPresentIf</code></dt>
                <dd>The object is a string literal containing a HEL expression. The field or struct is only present if the expression evaluates to <code>true</code>.</dd>
                <dt><code>bddo:repeatUntil</code></dt>
                <dd>The object is a string literal containing a HEL expression. The struct repeats until the expression evaluates to <code>true</code>.</dd>
            </dl>
        </section>
        <section>
            <h3>Data Type Description Properties</h3>
            <p>These properties are used on instances of <code>bddo:DataType</code> to describe their characteristics.</p>
            <dl>
                <dt><code>bddo:baseType</code></dt>
                <dd>Specifies the fundamental kind of data. The value MUST be one of the individuals <code>bddo:integer</code>, <code>bddo:float</code>, or <code>bddo:string</code>.</dd>
                <dt><code>bddo:bitWidth</code></dt>
                <dd>Specifies the size of the data type in bits. The value MUST be an <code>xsd:positiveInteger</code>.</dd>
                <dt><code>bddo:isSigned</code></dt>
                <dd>An <code>xsd:boolean</code> indicating if an integer type is signed (true) or unsigned (false).</dd>
                <dt><code>bddo:hasEndianness</code></dt>
                <dd>Specifies the byte order for a multi-byte data type. The value MUST be one of the individuals <code>bddo:BigEndian</code> or <code>bddo:LittleEndian</code>.</dd>
            </dl>
        </section>
    </section>

    <section id="normative-owl">
        <h2>Normative OWL Ontology</h2>
        <p>The following is the complete, normative OWL ontology for BDDO version 1.1, expressed in Turtle syntax [[turtle]].</p>
        <pre class="nohighlight">
@prefix : &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

&lt;https://hexplain.io/ns/bddo&gt; a owl:Ontology ;
    owl:versionInfo "1.1" ;
    rdfs:label "Binary Data Description Ontology (BDDO)" ;
    rdfs:comment "A core ontology of the Hexplain family for describing the physical layout of binary data." .

# -- Classes --
:Struct a rdfs:Class ; rdfs:label "Struct" .
:Field a rdfs:Class ; rdfs:label "Field" .
:DataType a rdfs:Class ; rdfs:label "Data Type" .

# -- Structural Properties --
:hasField a owl:ObjectProperty ; rdfs:domain :Struct ; rdfs:range rdf:List .
:usesStruct a owl:ObjectProperty ; rdfs:domain :Struct ; rdfs:range :Struct .
:endianness a owl:ObjectProperty ; rdfs:domain :Struct .
:syncOnMarker a owl:DatatypeProperty ; rdfs:domain :Struct ; rdfs:range xsd:hexBinary .

# -- Field Properties --
:dataType a owl:ObjectProperty ; rdfs:domain :Field ; rdfs:range :DataType .
:size a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:positiveInteger .
:sizeFromField a owl:ObjectProperty ; rdfs:domain :Field ; rdfs:range :Field .
:terminator a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:hexBinary .
:hasFixedValue a owl:DatatypeProperty ; rdfs:domain :Field .

# -- Control Flow Properties --
:isPresentIf a owl:DatatypeProperty ; rdfs:range xsd:string .
:repeatUntil a owl:DatatypeProperty ; rdfs:domain :Struct ; rdfs:range xsd:string .

# -- DataType Description Properties --
:baseType a owl:ObjectProperty ; rdfs:domain :DataType .
:bitWidth a owl:DatatypeProperty ; rdfs:domain :DataType ; rdfs:range xsd:positiveInteger .
:isSigned a owl:DatatypeProperty ; rdfs:domain :DataType ; rdfs:range xsd:boolean .
:hasEndianness a owl:ObjectProperty ; rdfs:domain :DataType .

# -- Individuals --
:BigEndian a owl:NamedIndividual ; rdfs:label "Big Endian" .
:LittleEndian a owl:NamedIndividual ; rdfs:label "Little Endian" .
:integer a owl:NamedIndividual ; rdfs:label "Base type Integer" .
:float a owl:NamedIndividual ; rdfs:label "Base type Float" .
:string a owl:NamedIndividual ; rdfs:label "Base type String" .

# -- Core Primitive DataType Instances --
:uint8    a :DataType ; rdfs:label "Unsigned 8-bit integer" ; :baseType :integer ; :bitWidth 8 ; :isSigned "false"^^xsd:boolean .
:int8     a :DataType ; rdfs:label "Signed 8-bit integer" ; :baseType :integer ; :bitWidth 8 ; :isSigned "true"^^xsd:boolean .
:uint16be a :DataType ; rdfs:label "Big-endian unsigned 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint16le a :DataType ; rdfs:label "Little-endian unsigned 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int16be  a :DataType ; rdfs:label "Big-endian signed 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int16le  a :DataType ; rdfs:label "Little-endian signed 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:uint32be a :DataType ; rdfs:label "Big-endian unsigned 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint32le a :DataType ; rdfs:label "Little-endian unsigned 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int32be  a :DataType ; rdfs:label "Big-endian signed 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int32le  a :DataType ; rdfs:label "Little-endian signed 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:uint64be a :DataType ; rdfs:label "Big-endian unsigned 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint64le a :DataType ; rdfs:label "Little-endian unsigned 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int64be  a :DataType ; rdfs:label "Big-endian signed 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int64le  a :DataType ; rdfs:label "Little-endian signed 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:float32be a :DataType ; rdfs:label "Big-endian IEEE 754 32-bit float" ; :baseType :float ; :bitWidth 32 ; :hasEndianness :BigEndian .
:float32le a :DataType ; rdfs:label "Little-endian IEEE 754 32-bit float" ; :baseType :float ; :bitWidth 32 ; :hasEndianness :LittleEndian .
:float64be a :DataType ; rdfs:label "Big-endian IEEE 754 64-bit float" ; :baseType :float ; :bitWidth 64 ; :hasEndianness :BigEndian .
:float64le a :DataType ; rdfs:label "Little-endian IEEE 754 64-bit float" ; :baseType :float ; :bitWidth 64 ; :hasEndianness :LittleEndian .
:bytes    a :DataType ; rdfs:label "Raw byte array" .
:string   a :DataType ; rdfs:label "String" ; :baseType :string .
        </pre>
    </section>

    <section id="normative-shacl">
        <h2>Normative SHACL Shapes</h2>
        <p>A BDDO description graph MUST conform to the following SHACL shapes [[shacl]]. These shapes ensure the structural integrity of the description itself.</p>
        <pre class="nohighlight">
@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

# -- Shape for validating a bddo:Struct --
bddo:StructShape a sh:NodeShape ;
    sh:targetClass bddo:Struct ;
    sh:property [
        sh:path bddo:hasField ;
        sh:nodeKind sh:BlankNodeOrIRI ;
        sh:maxCount 1 ;
        sh:message "bddo:hasField must point to a single rdf:List."
    ] ;
    sh:property [
        sh:path bddo:endianness ;
        sh:in ( bddo:BigEndian bddo:LittleEndian ) ;
        sh:maxCount 1 ;
        sh:message "bddo:endianness must be bddo:BigEndian or bddo:LittleEndian."
    ] .

# -- Shape for validating a bddo:Field --
bddo:FieldShape a sh:NodeShape ;
    sh:targetClass bddo:Field ;
    sh:property [
        sh:path bddo:dataType ;
        sh:class bddo:DataType ;
        sh:nodeKind sh:IRI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A bddo:Field must have exactly one bddo:dataType which must be an instance of bddo:DataType."
    ] ;
    sh:property [
        sh:path bddo:sizeFromField ;
        sh:class bddo:Field ;
        sh:maxCount 1 ;
        sh:message "bddo:sizeFromField must point to another bddo:Field."
    ] ;
    # A field cannot have more than one sizing mechanism.
    sh:xone (
        [ sh:path bddo:size ]
        [ sh:path bddo:sizeFromField ]
        [ sh:path bddo:terminator ]
    ) .

# -- Shape for validating a bddo:DataType --
bddo:DataTypeShape a sh:NodeShape ;
    sh:targetClass bddo:DataType ;
    sh:property [
        sh:path bddo:baseType ;
        sh:in ( bddo:integer bddo:float bddo:string ) ;
        sh:maxCount 1 ;
        sh:message "A DataType's baseType must be one of bddo:integer, bddo:float, or bddo:string."
    ] .
        </pre>
    </section>

    <section id="normative-jsonld-context">
        <h2>Normative JSON-LD Context</h2>
        <p>
            A Hexplain processor SHOULD use a [[JSON-LD]] context to map simple string keys to the full BDDO URIs. This is particularly relevant for the evaluation of HEL expressions, where simple keys are used to access fields in the logical data model. The following context provides the normative mapping for all terms defined in the BDDO 1.1 specification.
        </p>
        <pre class="nohighlight">
{
  "@context": {
    "bddo": "https://hexplain.io/ns/bddo#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",

    "Struct": "bddo:Struct",
    "Field": "bddo:Field",
    "DataType": "bddo:DataType",

    "hasField": { "@id": "bddo:hasField", "@container": "@list" },
    "usesStruct": { "@id": "bddo:usesStruct", "@type": "@id" },
    "endianness": { "@id": "bddo:endianness", "@type": "@id" },
    "syncOnMarker": { "@id": "bddo:syncOnMarker", "@type": "xsd:hexBinary" },
    
    "dataType": { "@id": "bddo:dataType", "@type": "@id" },
    "size": { "@id": "bddo:size", "@type": "xsd:positiveInteger" },
    "sizeFromField": { "@id": "bddo:sizeFromField", "@type": "@id" },
    "terminator": { "@id": "bddo:terminator", "@type": "xsd:hexBinary" },
    "hasFixedValue": "bddo:hasFixedValue",

    "isPresentIf": "bddo:isPresentIf",
    "repeatUntil": "bddo:repeatUntil",

    "baseType": { "@id": "bddo:baseType", "@type": "@id" },
    "bitWidth": { "@id": "bddo:bitWidth", "@type": "xsd:positiveInteger" },
    "isSigned": { "@id": "bddo:isSigned", "@type": "xsd:boolean" },
    "hasEndianness": { "@id": "bddo:hasEndianness", "@type": "@id" }
  }
}
        </pre>
    </section>

 
    <section id="examples" class="introductory">
        <h2>Examples</h2>
        <p>The following examples demonstrate how to use BDDO to describe common binary structures.</p>
        <section>
            <h3>Complete File with Header and Data</h3>
            <p>This example shows a simple, complete file format with a magic number, a version, and a dynamically sized payload. It demonstrates <code>hasFixedValue</code> and <code>sizeFromField</code>.</p>
            <pre class="nohighlight">
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix ex: &lt;https://hexplain.io/formats/example#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:TaggedFile a bddo:Struct ;
    bddo:endianness bddo:BigEndian ;
    bddo:hasField ( 
        ex:Magic, 
        ex:Version, 
        ex:PayloadSize, 
        ex:Payload 
    ) .

ex:Magic a bddo:Field ;
    bddo:dataType bddo:bytes ;
    bddo:size 4 ;
    bddo:hasFixedValue "TAG1"^^xsd:string .

ex:Version a bddo:Field ; bddo:dataType bddo:uint8 .

ex:PayloadSize a bddo:Field ; bddo:dataType bddo:uint32be .

ex:Payload a bddo:Field ;
    bddo:dataType bddo:bytes ;
    bddo:sizeFromField ex:PayloadSize .
            </pre>
        </section>
        <section>
            <h3>Null-Terminated String</h3>
            <p>This example describes a field containing a C-style null-terminated string, using the <code>bddo:terminator</code> property.</p>
            <pre class="nohighlight">
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix ex: &lt;https://hexplain.io/formats/example#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:Record a bddo:Struct ;
    bddo:hasField ( ex:Name ) .

ex:Name a bddo:Field ;
    bddo:dataType bddo:string ;
    bddo:terminator "00"^^xsd:hexBinary .
            </pre>
        </section>
        <section>
            <h3>Reusable Structures (PNG Chunks)</h3>
            <p>This example shows how to define a reusable template for a PNG chunk using a profile, and then use it in a repeating structure. It demonstrates <code>usesStruct</code> and <code>repeatUntil</code>.</p>
            <pre class="nohighlight">
# In a profile file (e.g., png-profile.ttl)
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix png_profile: &lt;https://hexplain.io/ns/profiles/png#&gt; .

png_profile:Chunk a bddo:Struct ;
    bddo:endianness bddo:BigEndian ;
    bddo:hasField ( png_profile:Length, png_profile:Type, ... ) .
# ...

# In the main PNG format description
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix png: &lt;https://hexplain.io/formats/png#&gt; .
@prefix png_profile: &lt;https://hexplain.io/ns/profiles/png#&gt; .

png:ChunkSequence a bddo:Struct ;
    bddo:usesStruct png_profile:Chunk ;
    bddo:repeatUntil "instance.Type == 'IEND'" .
            </pre>
        </section>
        <section>
            <h3>Stream Synchronization (MPEG-2)</h3>
            <p>This example shows how to model a repeating sequence of MPEG-2 pictures, where each picture's location must be found by scanning for a specific start code marker. It demonstrates <code>syncOnMarker</code>.</p>
             <pre class="nohighlight">
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix mpeg: &lt;https://hexplain.io/formats/mpeg2#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

mpeg:Stream a bddo:Struct ;
    bddo:hasField ( mpeg:Pictures ) .

mpeg:Pictures a bddo:Struct ;
    bddo:repeatUntil "instance.isEOF" ;
    bddo:syncOnMarker "00000100"^^xsd:hexBinary ;
    bddo:hasField ( mpeg:PictureHeader, mpeg:PictureData ) .
            </pre>
        </section>
    </section>
</body>
</html>