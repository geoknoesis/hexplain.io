<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binary Data Description Ontology (BDDO) Specification</title>
    <!-- ReSpec script and configuration -->
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="respec" async></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            editors: [{
                name: "Stephane Fellah",
                url: "https://geoknoesis.com"
            }],
            // Note: The 'github' property is added back as requested.
            // This may cause a cross-origin security error in some sandboxed
            // environments, which was the source of the previous console error.
            github: "https://github.com/w3c/respec",
            shortName: "bddo",
            publishDate: "2025-08-16",
            subtitle: "Version 1.3",
        };
    </script>
</head>
<body>
    <section id="abstract">
        <p>
            The Binary Data Description Ontology (BDDO) provides a formal vocabulary to declaratively describe the structure, syntax, and layout of binary data. It is the foundational physical layer of the Hexplain Ontology Family. BDDO allows authors to model binary formats as a series of nested structures and typed fields, with support for dynamic layouts through conditional logic, variable sizing, and stream synchronization. This specification provides the normative OWL ontology for BDDO and a set of SHACL shapes for validating BDDO descriptions.
        </p>
    </section>

    <section id="sotd">
        <p>
            This document is an unofficial draft produced for the purpose of defining the Hexplain standard. It has no official standing and is not endorsed by any standards body. Version 1.3 introduces constructs for conditional data type dispatching. Version 1.2 moved repetition properties to <code>bddo:Field</code>. Version 1.1 introduced the <code>bddo:terminator</code> and <code>bddo:syncOnMarker</code> properties.
        </p>
    </section>

    <section class="introductory">
        <h2>Introduction</h2>
        <p>
            The primary goal of the Hexplain project is to make opaque binary data machine-understandable. The first step in this process is to provide a standardized, unambiguous way to describe the physical structure of the data. The Binary Data Description Ontology (BDDO) serves this purpose.
        </p>
        <p>
            BDDO provides a set of RDF classes and properties that can be used to create a graph-based model of a binary format. This model can then be used by a conforming Hexplain processor to parse a binary stream into a structured, logical representation.
        </p>
        <section>
            <h3>Conformance</h3>
            <p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119]].
            </p>
        </section>
    </section>

    <section id="core-concepts">
        <h2>Core Concepts</h2>
        <p>The BDDO model is built upon the following fundamental classes.</p>
        <dl>
            <dt><code>bddo:Struct</code></dt>
            <dd>Represents a composite structure or a container for other elements. A Struct is an ordered sequence of Fields. Examples include a file header, a network packet, or a PNG chunk.</dd>
            <dt><code>bddo:Field</code></dt>
            <dd>Represents a single element within a Struct. A Field can represent a single value (like an integer) or a sequence of values (an array). It is always associated with a specific data type.</dd>
            <dt><code>bddo:DataType</code></dt>
            <dd>Represents the type of data a Field contains. BDDO defines a set of core primitive data types (e.g., <code>bddo:uint32be</code>). This class can be extended in "profiles" to create user-defined type aliases (e.g., <code>media:fourCC</code>).</dd>
            <dt><code>bddo:DataTypeRule</code></dt>
            <dd>Represents a single rule for conditionally selecting a data type for a field. It consists of a condition and the data type to use if the condition is met.</dd>
        </dl>
    </section>

    <section id="core-datatypes">
        <h2>Core Data Types</h2>
        <p>BDDO provides a normative set of built-in primitive data types. All conforming Hexplain processors MUST support these types. Each type is a formal instance of <code>bddo:DataType</code> and is described by the properties defined in the ontology.</p>
        
        <h3>Integer Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                    <th>bitWidth</th>
                    <th>isSigned</th>
                    <th>hasEndianness</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:uint8</code></td><td>Unsigned 8-bit integer</td><td>8</td><td>false</td><td>N/A</td></tr>
                <tr><td><code>bddo:int8</code></td><td>Signed 8-bit integer</td><td>8</td><td>true</td><td>N/A</td></tr>
                <tr><td><code>bddo:uint16be</code></td><td>Big-endian unsigned 16-bit integer</td><td>16</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint16le</code></td><td>Little-endian unsigned 16-bit integer</td><td>16</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int16be</code></td><td>Big-endian signed 16-bit integer</td><td>16</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int16le</code></td><td>Little-endian signed 16-bit integer</td><td>16</td><td>true</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:uint32be</code></td><td>Big-endian unsigned 32-bit integer</td><td>32</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint32le</code></td><td>Little-endian unsigned 32-bit integer</td><td>32</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int32be</code></td><td>Big-endian signed 32-bit integer</td><td>32</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int32le</code></td><td>Little-endian signed 32-bit integer</td><td>32</td><td>true</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:uint64be</code></td><td>Big-endian unsigned 64-bit integer</td><td>64</td><td>false</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:uint64le</code></td><td>Little-endian unsigned 64-bit integer</td><td>64</td><td>false</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:int64be</code></td><td>Big-endian signed 64-bit integer</td><td>64</td><td>true</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:int64le</code></td><td>Little-endian signed 64-bit integer</td><td>64</td><td>true</td><td>LittleEndian</td></tr>
            </tbody>
        </table>

        <h3>Floating-Point Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                    <th>bitWidth</th>
                    <th>hasEndianness</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:float32be</code></td><td>Big-endian IEEE 754 32-bit float</td><td>32</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:float32le</code></td><td>Little-endian IEEE 754 32-bit float</td><td>32</td><td>LittleEndian</td></tr>
                <tr><td><code>bddo:float64be</code></td><td>Big-endian IEEE 754 64-bit float</td><td>64</td><td>BigEndian</td></tr>
                <tr><td><code>bddo:float64le</code></td><td>Little-endian IEEE 754 64-bit float</td><td>64</td><td>LittleEndian</td></tr>
            </tbody>
        </table>

        <h3>Other Types</h3>
        <table class="simple">
            <thead>
                <tr>
                    <th>IRI</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>bddo:bytes</code></td><td>Raw byte array. Requires a sizing property (e.g., <code>bddo:size</code>) or a termination property (<code>bddo:terminator</code>).</td></tr>
                <tr><td><code>bddo:string</code></td><td>String. Requires a sizing property or a termination property. May have an encoding property.</td></tr>
            </tbody>
        </table>
    </section>

    <section id="properties">
        <h2>Properties</h2>
        <p>Properties are the predicates that define the characteristics of Structs, Fields, and DataTypes.</p>
        <section>
            <h3>Structural Properties</h3>
            <dl>
                <dt><code>bddo:hasField</code></dt>
                <dd>Links a <code>bddo:Struct</code> to its constituent components. The object of this property MUST be an <code>rdf:List</code> to preserve the order of the fields.</dd>
                <dt><code>bddo:endianness</code></dt>
                <dd>Specifies the byte order for a <code>bddo:Struct</code>. The value MUST be one of the individuals <code>bddo:BigEndian</code> or <code>bddo:LittleEndian</code>.</dd>
                <dt><code>bddo:syncOnMarker</code></dt>
                <dd>Specifies a byte sequence that a processor MUST scan for before parsing this <code>bddo:Struct</code>. The value MUST be an <code>xsd:hexBinary</code> literal.</dd>
            </dl>
        </section>
        <section>
            <h3>Field Properties</h3>
            <dl>
                <dt><code>bddo:dataType</code></dt>
                <dd>Links a <code>bddo:Field</code> to its default data type. The value MUST be an instance of <code>bddo:DataType</code> or <code>bddo:Struct</code>.</dd>
                <dt><code>bddo:hasConditionalDataType</code></dt>
                <dd>Links a <code>bddo:Field</code> to an <code>rdf:List</code> of <code>bddo:DataTypeRule</code>s. This allows the parser to select a more specific data type for the field at runtime based on conditions.</dd>
                <dt><code>bddo:size</code></dt>
                <dd>Defines a fixed size in bytes for a field. The value MUST be an <code>xsd:positiveInteger</code>.</dd>
                <dt><code>bddo:sizeFromField</code></dt>
                <dd>For dynamic sizing, this property points to another <code>bddo:Field</code> in the structure whose value dictates the size of the current field.</dd>
                <dt><code>bddo:terminator</code></dt>
                <dd>Specifies a byte sequence that terminates a variable-length field. The value MUST be an <code>xsd:hexBinary</code> literal.</dd>
                <dt><code>bddo:hasFixedValue</code></dt>
                <dd>Specifies a constant value for a field, used for validating markers and magic numbers.</dd>
                <dt><code>bddo:isPresentIf</code></dt>
                <dd>The object is a string literal containing a HEL expression. The field is only present if the expression evaluates to <code>true</code>.</dd>
                <dt><code>bddo:repeatUntil</code></dt>
                <dd>The object is a string literal containing a HEL expression. The field is parsed repeatedly until the expression evaluates to <code>true</code>, resulting in an array of values.</dd>
            </dl>
        </section>
        <section>
            <h3>Data Type Description Properties</h3>
            <p>These properties are used on instances of <code>bddo:DataType</code> to describe their characteristics.</p>
            <dl>
                <dt><code>bddo:baseType</code></dt>
                <dd>Specifies the fundamental kind of data. The value MUST be one of the individuals <code>bddo:integer</code>, <code>bddo:float</code>, or <code>bddo:string</code>.</dd>
                <dt><code>bddo:bitWidth</code></dt>
                <dd>Specifies the size of the data type in bits. The value MUST be an <code>xsd:positiveInteger</code>.</dd>
                <dt><code>bddo:isSigned</code></dt>
                <dd>An <code>xsd:boolean</code> indicating if an integer type is signed (true) or unsigned (false).</dd>
                <dt><code>bddo:hasEndianness</code></dt>
                <dd>Specifies the byte order for a multi-byte data type. The value MUST be one of the individuals <code>bddo:BigEndian</code> or <code>bddo:LittleEndian</code>.</dd>
            </dl>
        </section>
    </section>

    <section id="normative-owl">
        <h2>Normative OWL Ontology</h2>
        <p>The following is the complete, normative OWL ontology for BDDO version 1.3, expressed in Turtle syntax [[turtle]].</p>
        <pre class="nohighlight">
@prefix : &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

&lt;https://hexplain.io/ns/bddo&gt; a owl:Ontology ;
    owl:versionInfo "1.3" ;
    rdfs:label "Binary Data Description Ontology (BDDO)" .

# -- Classes --
:Struct a rdfs:Class ; rdfs:label "Struct" .
:Field a rdfs:Class ; rdfs:label "Field" .
:DataType a rdfs:Class ; rdfs:label "Data Type" .
:DataTypeRule a rdfs:Class ; rdfs:label "Data Type Rule" .

# -- Structural Properties --
:hasField a owl:ObjectProperty ; rdfs:domain :Struct ; rdfs:range rdf:List .
:endianness a owl:ObjectProperty ; rdfs:domain :Struct .
:syncOnMarker a owl:DatatypeProperty ; rdfs:domain :Struct ; rdfs:range xsd:hexBinary .

# -- Field Properties --
:dataType a owl:ObjectProperty ; rdfs:domain :Field ; rdfs:range [ a owl:Class ; owl:unionOf ( :DataType :Struct ) ] .
:hasConditionalDataType a owl:ObjectProperty ; rdfs:domain :Field ; rdfs:range rdf:List .
:size a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:positiveInteger .
:sizeFromField a owl:ObjectProperty ; rdfs:domain :Field ; rdfs:range :Field .
:terminator a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:hexBinary .
:hasFixedValue a owl:DatatypeProperty ; rdfs:domain :Field .
:isPresentIf a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:string .
:repeatUntil a owl:DatatypeProperty ; rdfs:domain :Field ; rdfs:range xsd:string .

# -- DataTypeRule Properties --
:condition a owl:DatatypeProperty ; rdfs:domain :DataTypeRule ; rdfs:range xsd:string .
:dataType a owl:ObjectProperty ; rdfs:domain :DataTypeRule ; rdfs:range :Struct .

# -- DataType Description Properties --
:baseType a owl:ObjectProperty ; rdfs:domain :DataType .
:bitWidth a owl:DatatypeProperty ; rdfs:domain :DataType ; rdfs:range xsd:positiveInteger .
:isSigned a owl:DatatypeProperty ; rdfs:domain :DataType ; rdfs:range xsd:boolean .
:hasEndianness a owl:ObjectProperty ; rdfs:domain :DataType .

# -- Individuals --
:BigEndian a owl:NamedIndividual ; rdfs:label "Big Endian" .
:LittleEndian a owl:NamedIndividual ; rdfs:label "Little Endian" .
:integer a owl:NamedIndividual ; rdfs:label "Base type Integer" .
:float a owl:NamedIndividual ; rdfs:label "Base type Float" .
:string a owl:NamedIndividual ; rdfs:label "Base type String" .
:bytes a owl:NamedIndividual ; rdfs:label "Base type Bytes" .

# -- Core Primitive DataType Instances --
:uint8    a :DataType ; rdfs:label "Unsigned 8-bit integer" ; :baseType :integer ; :bitWidth 8 ; :isSigned "false"^^xsd:boolean .
:int8     a :DataType ; rdfs:label "Signed 8-bit integer" ; :baseType :integer ; :bitWidth 8 ; :isSigned "true"^^xsd:boolean .
:uint16be a :DataType ; rdfs:label "Big-endian unsigned 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint16le a :DataType ; rdfs:label "Little-endian unsigned 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int16be  a :DataType ; rdfs:label "Big-endian signed 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int16le  a :DataType ; rdfs:label "Little-endian signed 16-bit integer" ; :baseType :integer ; :bitWidth 16 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:uint32be a :DataType ; rdfs:label "Big-endian unsigned 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint32le a :DataType ; rdfs:label "Little-endian unsigned 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int32be  a :DataType ; rdfs:label "Big-endian signed 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int32le  a :DataType ; rdfs:label "Little-endian signed 32-bit integer" ; :baseType :integer ; :bitWidth 32 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:uint64be a :DataType ; rdfs:label "Big-endian unsigned 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :BigEndian .
:uint64le a :DataType ; rdfs:label "Little-endian unsigned 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "false"^^xsd:boolean ; :hasEndianness :LittleEndian .
:int64be  a :DataType ; rdfs:label "Big-endian signed 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :BigEndian .
:int64le  a :DataType ; rdfs:label "Little-endian signed 64-bit integer" ; :baseType :integer ; :bitWidth 64 ; :isSigned "true"^^xsd:boolean ; :hasEndianness :LittleEndian .
:float32be a :DataType ; rdfs:label "Big-endian IEEE 754 32-bit float" ; :baseType :float ; :bitWidth 32 ; :hasEndianness :BigEndian .
:float32le a :DataType ; rdfs:label "Little-endian IEEE 754 32-bit float" ; :baseType :float ; :bitWidth 32 ; :hasEndianness :LittleEndian .
:float64be a :DataType ; rdfs:label "Big-endian IEEE 754 64-bit float" ; :baseType :float ; :bitWidth 64 ; :hasEndianness :BigEndian .
:float64le a :DataType ; rdfs:label "Little-endian IEEE 754 64-bit float" ; :baseType :float ; :bitWidth 64 ; :hasEndianness :LittleEndian .
:bytes    a :DataType ; rdfs:label "Raw byte array" ; :baseType :bytes .
:string   a :DataType ; rdfs:label "String" ; :baseType :string .
        </pre>
    </section>

    <section id="normative-shacl">
        <h2>Normative SHACL Shapes</h2>
        <p>A BDDO description graph MUST conform to the following SHACL shapes [[shacl]].</p>
        <pre class="nohighlight">
@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

# -- Shape for validating a bddo:Struct --
bddo:StructShape a sh:NodeShape ;
    sh:targetClass bddo:Struct ;
    sh:property [
        sh:path bddo:hasField ;
        sh:nodeKind sh:BlankNodeOrIRI ;
        sh:maxCount 1 ;
        sh:message "bddo:hasField must point to a single rdf:List."
    ] .

# -- Shape for validating a bddo:Field --
bddo:FieldShape a sh:NodeShape ;
    sh:targetClass bddo:Field ;
    sh:property [
        sh:path bddo:dataType ;
        sh:nodeKind sh:IRI ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "A bddo:Field must have exactly one bddo:dataType."
    ] .

# -- Shape for validating a bddo:DataTypeRule --
bddo:DataTypeRuleShape a sh:NodeShape ;
    sh:targetClass bddo:DataTypeRule ;
    sh:property [
        sh:path bddo:condition ;
        sh:minCount 1 ; sh:maxCount 1 ;
        sh:message "A DataTypeRule MUST have exactly one bddo:condition."
    ] ;
    sh:property [
        sh:path bddo:dataType ;
        sh:class bddo:Struct ;
        sh:minCount 1 ; sh:maxCount 1 ;
        sh:message "The dataType of a DataTypeRule MUST be a single bddo:Struct."
    ] .
        </pre>
    </section>
    
    <section id="normative-jsonld-context">
        <h2>Normative JSON-LD Context</h2>
        <p>
            The following context provides the normative [[JSON-LD]] mapping for all terms defined in the BDDO 1.3 specification.
        </p>
        <pre class="nohighlight">
{
  "@context": {
    "bddo": "https://hexplain.io/ns/bddo#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",

    "Struct": "bddo:Struct",
    "Field": "bddo:Field",
    "DataType": "bddo:DataType",
    "DataTypeRule": "bddo:DataTypeRule",

    "hasField": { "@id": "bddo:hasField", "@container": "@list" },
    "endianness": { "@id": "bddo:endianness", "@type": "@id" },
    "syncOnMarker": { "@id": "bddo:syncOnMarker", "@type": "xsd:hexBinary" },
    
    "dataType": { "@id": "bddo:dataType", "@type": "@id" },
    "hasConditionalDataType": { "@id": "bddo:hasConditionalDataType", "@container": "@list" },
    "size": { "@id": "bddo:size", "@type": "xsd:positiveInteger" },
    "sizeFromField": { "@id": "bddo:sizeFromField", "@type": "@id" },
    "terminator": { "@id": "bddo:terminator", "@type": "xsd:hexBinary" },
    "hasFixedValue": "bddo:hasFixedValue",

    "isPresentIf": "bddo:isPresentIf",
    "repeatUntil": "bddo:repeatUntil",

    "condition": "bddo:condition",

    "baseType": { "@id": "bddo:baseType", "@type": "@id" },
    "bitWidth": { "@id": "bddo:bitWidth", "@type": "xsd:positiveInteger" },
    "isSigned": { "@id": "bddo:isSigned", "@type": "xsd:boolean" },
    "hasEndianness": { "@id": "bddo:hasEndianness", "@type": "@id" }
  }
}
        </pre>
    </section>

    <section id="example" class="introductory">
        <h2>Example: Conditional Data Type Dispatch</h2>
        <p>
            This example shows how to use <code>bddo:hasConditionalDataType</code> to model the PNG chunk structure. A generic chunk is parsed first, and then the <code>ChunkData</code> field is re-parsed using a more specific structure based on the value of the <code>ChunkType</code> field.
        </p>
        <p>
            This mechanism is crucial for formats that use a type-length-value (TLV) or chunk-based structure, where a single field (the "value" or "data") can contain different internal structures depending on a preceding type identifier.
        </p>
        <pre class="nohighlight">
@prefix bddo: &lt;https://hexplain.io/ns/bddo#&gt; .
@prefix png: &lt;https://hexplain.io/formats/png#&gt; .
@prefix png_profile: &lt;https://hexplain.io/ns/profiles/png#&gt; .

# Generic Chunk Structure defined in a profile
png_profile:Chunk a bddo:Struct ;
    bddo:hasField ( png_profile:ChunkLength, png_profile:ChunkType, png_profile:ChunkData, png_profile:ChunkCRC ) .

png_profile:ChunkData a bddo:Field ;
    # Default type is raw bytes.
    bddo:dataType bddo:bytes ;
    bddo:sizeFromField png_profile:ChunkLength ;
    
    # Conditionally dispatch to a more specific struct for parsing.
    bddo:hasConditionalDataType (
        [
            a bddo:DataTypeRule ;
            bddo:condition "instance.parent.ChunkType == 'IHDR'" ;
            bddo:dataType png:IHDR_ChunkData
        ]
        [
            a bddo:DataTypeRule ;
            bddo:condition "instance.parent.ChunkType == 'PLTE'" ;
            bddo:dataType png:PLTE_ChunkData
        ]
        # ... rules for other chunk types ...
    ) .
        </pre>
    </section>
</body>
</html>
